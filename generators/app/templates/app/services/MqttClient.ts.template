/*
  MqttClient
    Manages connection with devices via MQTT broker
*/

import { EventEmitter } from 'events';
import * as mqtt from 'mqtt';
import { TokenG } from './../libraries/TokenG';
import { log } from './../libraries/Log';
import { config } from './../config/config';
import { Device } from './../models/Device';
import { MqttRequester } from './../libraries/MqttRequest';
import DeviceService from './DeviceService';
import * as _ from 'lodash';
import KissNetService from './KissNetService';

class MqttClient extends EventEmitter {

  public client: mqtt.Client;
  private token: TokenG;
  public mqttReq: MqttRequester;

  constructor() {
    super();
  }

  init() {
    this.token = new TokenG(config.mqtt.user_secret, config.mqtt.user_map, config.mqtt.password_secret, config.mqtt.password_map);

    const options: mqtt.ClientOptions = {
      keepalive: config.mqtt.keepalive,
      username: this.token.getUser(),
      connectTimeout: config.mqtt.connectTimeout,
      password: this.token.getPassword(),
      clientId: config.mqtt.clientId
    };

    this.client = mqtt.connect(config.mqtt.uri, options);

    KissNetService.init(this.client);

    this.mqttReq = new MqttRequester(this.client);

    this.client.on('connect', () => {
      this.client.subscribe("+/connect");
      this.client.subscribe("+/disconnect");
      this.client.subscribe("+/+/res");
      this.client.subscribe("+/+/rep");

      // KISSnet
      this.client.subscribe("+/kno/+/#");
      this.client.subscribe("+/kno/+/#");
      this.client.subscribe("+/+/req");

      log.info("MqttClient Online");
    });

    this.client.on('error', (error) => {
      log.error("MqttClient error:", error);
      throw new Error("MqttClient failed to connect, forcing restart...");
    });

    this.client.on('offline', () => {
      log.error("MqttClient Offline!");
    });

    this.client.on('reconnect', () => {
      log.debug("MqttClient trying to reconnect");
    });

    this.client.on('close', () => {
      // Update tokens on disconnection from broker
      this.client.options.username = this.token.getUser();
      this.client.options.password = this.token.getPassword();
      log.debug("MqttClient connection closed");
    });

    this.client.on('message', (topic, message) => {

      let parsedTopic = topic.split('/');
      let udid = parsedTopic[0];
      let action = parsedTopic[1];
      let type = parsedTopic[2];

      // Special case for KISSnet messages
      if(action === 'kno') return KissNetService.attendKissNet(topic, message);
      if(action === 'knpair' && type === 'rep') return KissNetService.attendKissNetPair(udid, message);

      let isResponse = type === 'res';
      let isReport = type === 'rep';

      if(action === 'connect') return this.onDeviceConnected(udid, message);
      if(action === 'disconnect') return this.onDeviceDisconnected(udid, message);

      if(isReport) {
        // Emit report
        this.emit('rep', { action: action, udid: udid, message: message });
        this.emit(`${action}/rep`, { udid: udid, message: message });
      }

      if(type === 'req') {
        // Check if needs to be resent to bridge
        KissNetService.attendReq(udid, action, message);
      }

    });

  }

  onDeviceConnected(udid: string, message: any) {
    if(!udid) return;

    let isFirstConnection: boolean = false;

    Device.findOne({ where: { udid: udid } })
    .then((device) => {
      if(!device) return Promise.reject(`No device found with udid ${udid}`);

      // Validate first connection
      if(!device.loggedAt) {
        isFirstConnection = true;
        device.loggedAt = new Date();
      }

      device.connected = true;
      device.state = 'connected';
      device.lastSeen = new Date();
      return device.save();
    })
    .then((updated) => {
      if(!updated) return Promise.reject(`Device not updated ${udid}`);
      let device = updated;

      // Give time for the connection to settle before requesting version
      // (For all the necessary subscriptions to be made)
      setTimeout(() => {
        DeviceService.requestVersion(device.id)
        .then(version => {
          this.emit('deviceConnected', updated);
          if(isFirstConnection) this.emit('deviceFirstConnection', updated);
        })
        .catch(err => {
          if(err) log.debug("Error requesting device version.", err);
        });
      }, 2000);

      return Promise.resolve(device);
    })
    .catch((err) => {
      if(err) return log.debug(err);
    });

  }

  onDeviceDisconnected(udid: string, message: any) {
    if(!udid) return;

    Device.findOne({ where: { udid: udid } })
    .then((device) => {
      if(!device) {
        log.debug(`No device found with udid ${udid}`);
        throw null;
      }

      device.connected = false;
      device.state = 'lost';
      device.lastSeen = new Date();

      return device.save();
    })
    .then((device) => {
      if(!device) {
        log.debug(`Device not updated, udid: ${udid}`);
        throw null;
      }
      this.emit('deviceDisconnected', device);
      return Device.findAll({where: {bridgeId: device.id }});
    })
    .then((devices) => {
      devices.each((device) => {
        this.client.publish(`${device.udid}/disconnect`, new Buffer([]));
      });
    })
    .catch((err) => {
      if(err) return log.error(err);
    });
  }

  publish(topic, payload) {
    this.client.publish(topic + "/req", payload);
  }

}

const mqttClient = new MqttClient();
export default mqttClient;